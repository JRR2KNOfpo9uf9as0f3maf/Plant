for i, bot in pairs(getBots()) do
    if getBot().name:upper() == bot.name:upper() then
        indexbot = i
    end
end

webhook = setting.webhook.infostorage.link
message = setting.webhook.infostorage.messageid
index = 1
param = indexbot * setting.farmList.worldperbot
timer = {}
infoid = {}
worlds = {}
strings = ""
local identity = {}
identity.param = setting.farmList.door
identity.takeseed = 1
identity.goodtime = os.time()

for i =  1,setting.farmList.worldperbot do
    table.insert(worlds,setting.farmList.world[math.floor((indexbot - 1) * setting.farmList.worldperbot + i)])
    identity.door = identity.param
end

identity.splitt = function(str, ptr)
    if not ptr then 
        ptr = "%s"
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

identity.botinfo = function(content)
	if setting.webhook.access then
		text = [[
			$webHookUrl = "]]..setting.webhook.status..[["
			$payload = @{
				content = "]]..content..[["
			}
			[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
			Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Post -ContentType "application/json"
		]]
		local file = io.popen("powershell -command -", "w")
		file:write(text)
		file:close()
	end
end

identity.botstatus = function()
    strings = ""
    for _, bot in pairs(getBots()) do
        if setting.webhook.short then
            strings = strings.."\n"..""..(string.sub(bot.name,1,3)).." | ||"..(string.sub(bot.world,1,3)).."|| | "..(string.sub(bot.status,1,2)).."" 
        else
            strings = strings.."\n"..""..(string.upper(bot.name)).." | ||"..(string.upper(bot.world)).."|| | "..(string.upper(bot.status)).."" 
        end
    end
    return strings
end

identity.storagename = function()
    strings = ""
	for i = 1, #setting.storage.world do
        if setting.webhook.short then
    		strings = strings.."\n||"..(string.sub(setting.storage.world[i],1,3)).."|| "..(infoid[setting.storage.world[i]] or "?")..""
        else
    		strings = strings.."\n||"..(string.upper(setting.storage.world[i])).."|| "..(infoid[setting.storage.world[i]] or "?")..""
        end
    end
    return strings
end

identity.farmname = function()
    strings = ""
	for i = 1, #setting.farmList.world do
        if setting.webhook.short then
    		strings = strings.."\n||"..(string.sub(setting.farmList.world[i],1,3)).."|| : "..(timer[setting.farmList.world[i]] or "?")..""
        else
    		strings = strings.."\n||"..(string.upper(setting.farmList.world[i])).."|| : "..(timer[setting.farmList.world[i]] or "?")..""
        end
	end
	return strings
end

identity.webhookinfo = function()
	if setting.webhook.access then
        local text = [[
            $webHookUrl = "]]..webhook..[[/messages/]]..message..[["
            $payload = @{
                username = "BizzantiuM's"
                embeds = @(
                    @{
                        title = "AUTO PLANT v1.1"
                        color = "]]..math.random(111111,999999)..[["
                        fields = @(
                            @{
                                name = ""
                                value = "]].."RUNNING : [ "..identity.goodtimes(os.difftime(os.time(),identity.goodtime)).." ]"..[["
                                inline = "false"
                            }
                            @{
                                name = "BOT INFO"
                                value = "]]..identity.botstatus()..[["
                                inline = "false"
                            }
                            @{
                                name = "STORAGE STATIC"
                                value = "]]..identity.storagename()..[["
                                inline = "true"
                            }
                            @{
                                name = "WORLD STATIC"
                                value = "]]..identity.farmname()..[["
                                inline = "false"
                            }
                        )
                        footer = @{
                            text = "[Hydrotrium] Developed by BizzantiuM's`nLast updated : ]]..(os.date"%d/%m/%y":upper().." at ")..os.date("%I")..":"..os.date("%M").." "..os.date("%p"):upper()..[["
                        }
                    }
                )
            }
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Patch -ContentType 'application/json'
        ]]
        local pipe = io.popen("powershell -command -", "w")
        pipe:write(text)
        pipe:close()
    end
end

identity.round = function(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

identity.reconnect = function(world,id,x,y)
    if getBot().world == "EXIT" then 
        identity.botinfo("[ ||"..getBot().name.."|| ] stuck EXIT ??, trying to joining world again @everyone")
        print("[ "..getBot().name.." ] stuck EXIT ??, trying to joining world again")
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
            sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
            sleep(setting.delay.warp)
            if getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg ~= 6 then
                while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                    findPath(x,y)
                    sleep(150)
                end
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] success to joining world @everyone")
        print("[ "..getBot().name.." ] success to joining world")
    end
    if getBot().status ~= "online" then
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "ercon" then
                identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status..", removing bot @everyone")
                print("[ "..getBot().name.." ] status is "..getBot().status..", removing bot")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
        end
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
            sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
            sleep(setting.delay.warp)
            if getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg ~= 6 then
                while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                    findPath(x,y)
                    sleep(150)
                end
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
    end
    while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
        sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
        sleep(setting.delay.warp)
        if getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg ~= 6 then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(150)
            end
        end
    end
end

identity.warp = function(world,door)
    name = world
    door = identity.door
    if identity.door then
        name = name .. "|" ..identity.door
    end
    if getBot().world ~= string.upper(world) then
        addHook("onvariant","nuked",function (varlist)
            if varlist[0] == "OnConsoleMessage" then
                if string.find(varlist[1],"inaccessible.") then
                    nuked = true
                end
            end
        end)
        while getBot().world ~= string.upper(world) and not nuked do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        removeHooks()
        sleep(1000)
    end
    if identity.door and getBot().world == string.upper(world) then
        local stuck = 0
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 and not wrong do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

identity.itemFloat = function(id)
	local count = 0
	for _, obj in pairs(getObjects()) do
		if obj.id == id then
			count = count + obj.count
		end
	end
	return count
end

identity.goodtimes = function(estimates)
    local seconds = tonumber(estimates)
    if seconds <= 0 then
        return "00:00:00";
    else
        hours = string.format("%02.f", math.floor(estimates/3600));
        minutes = string.format("%02.f", math.floor(estimates/60 - (hours*60)));
        seconds = string.format("%02.f", math.floor(estimates - hours*3600 - minutes *60));
        return ""..hours.." : "..minutes.." : "..seconds
    end
end

identity.take = function(threads)
    for i = identity.takeseed , #setting.storage.world do
        setJob("Take seed")
		world = setting.storage.world[i]
        identity.door = setting.storage.id
        identity.warp(world,identity.door)
        identity.webhookinfo("Take seeds")
		if not nuked then
			if not wrong then
				if identity.itemFloat(setting.seed) == 0 then
					infoid[world] = ""..identity.itemFloat(setting.seed).." EMPTY !!"
					identity.botinfo("Seeds storage : [ ||"..world.."|| ] has empty, skipped world @everyone")
					print("Seeds storage : [ "..world.." ] has empty, skipped world")
					identity.takeseed = identity.takeseed + 1
					if identity.takeseed > #setting.storage.world then
						infoid[world] = ""..identity.itemFloat(setting.seed).." EMPTY !!"
						identity.botinfo("All seeds storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
						print("All seeds storage has empty, Removing bot : [ "..getBot().name.." ]")
						identity.webhookinfo("All seed storage has empty, Removing bot!")
						if setting.removeBot then
							removeBot(getBot().name)
							sleep(100)
						end
						error()
					end
				else
					for _, object in pairs(getObjects()) do
						if object.id == setting.seed then
							findPath(identity.round((object.x)/32), math.floor((object.y)/32))
							sleep(500)
							collect(2)
							sleep(500)
						end
						if findItem(setting.seed) > 0 then
							break
						end
					end
					if setting.mode.splice then
						for _, object in pairs(getObjects()) do
							if object.id == setting.mode.seed then
								findPath(identity.round((object.x)/32), math.floor((object.y)/32))
								sleep(500)
								collect(2)
								sleep(500)
							end
							if findItem(setting.mode.seed) > 0 then
								break
							end
						end
					end
					sleep(100)
					break
				end
			else
				infoid[world] = "WRONG DOOR ID"
				wrong = false
				sleep(1000)
				identity.botinfo("Seeds storage : [ ||"..world.."|| ] is wrong door id, skipped world @everyone")
				print("Seeds storage : [ "..world.." ] is wrong door id, skipped world")
				identity.takeseed = identity.takeseed + 1
				if identity.takeseed > #setting.storage.world then
					identity.botinfo("All seeds storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
					print("All seeds storage has empty, Removing bot : [ "..getBot().name.." ]")
					identity.webhookinfo("All seed storage has empty, Removing bot!")
					if setting.removeBot then
						removeBot(getBot().name)
						sleep(100)
					end
					error()
				end
			end
		else
			infoid[world] = "NUKED"
			nuked = false
			sleep(1000)
			identity.botinfo("Seeds storage : [ ||"..world.."|| ] is NUKED, skipped world @everyone")
			print("Seeds storage : [ "..world.." ] is NUKED, skipped world")
			identity.takeseed = identity.takeseed + 1
			if identity.takeseed > #setting.storage.world then
				identity.botinfo("All seeds storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
				print("All seeds storage has empty, Removing bot : [ "..getBot().name.." ]")
				identity.webhookinfo("All seed storage has empty, Removing bot!")
				if setting.removeBot then
					removeBot(getBot().name)
					sleep(100)
				end
				error()
			end
		end
	end
	infoid[world] = ""..identity.itemFloat(setting.seed)..""
	setJob("Planting")
end

identity.recheck = function(threads)
	identity.webhookinfo('Rechecking worlds')
	for _, tile in pairs(getTiles()) do
		for i = 1,2 do
			if tile.fg == 0 and getTile(tile.x, tile.y + 1).flags ~= 0 then
				if setting.mode.splice then
					if findItem(setting.seed) == 0 or findItem(setting.mode.seed) == 0 then
						identity.take(threads)
						identity.door = identity.param
						identity.warp(threads,identity.door)
					end
				else
					if findItem(setting.seed) == 0 then
						identity.take(threads)
						identity.door = identity.param
						identity.warp(threads,identity.door)
					end
				end
				findPath(tile.x,tile.y)
				identity.door = identity.param
				if setting.mode.splice then
					while getTile(tile.x,tile.y).fg ~= setting.seed do
						place(setting.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.door,tile.x,tile.y)
					end
					while getTile(tile.x,tile.y).fg == setting.seed do
						place(setting.mode.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.door,tile.x,tile.y)
					end
				else
					if getTile(tile.x,tile.y).fg ~= setting.seed then
						place(setting.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.door,tile.x,tile.y)
					end
				end
			end
		end
	end
end


identity.plant = function(threads)
	tileA = 99
	tileB = 0
	tileC = -1
	tileD = 0
	for y = -1, 53 do
		for x = tileA, tileB, tileC do
			if getTile(x, y).fg == 0 and getTile(x, y + 1).flags ~= 0 then
				if setting.mode.splice then
					if findItem(setting.seed) == 0 or findItem(setting.mode.seed) == 0 then
						identity.take(threads)
						identity.door = identity.param
						identity.warp(threads,identity.door)
					end
				else
					if findItem(setting.seed) == 0 then
						identity.take(threads)
						identity.door = identity.param
						identity.warp(threads,identity.door)
					end
				end
				identity.door = identity.param
				findPath(x,y)
				identity.reconnect(threads,identity.param,x,y)
				if setting.mode.splice then
					while getTile(x,y).fg ~= setting.seed do
						place(setting.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.param,x,y)
					end
					while getTile(x,y).fg == setting.seed do
						place(setting.mode.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.param,x,y)
					end
				else
					if getTile(x,y).fg ~= setting.seed then
						place(setting.seed,0,0)
						sleep(setting.delay.plant)
						identity.reconnect(threads,identity.param,x,y)
					end
				end
			end
		end
		if tileD == 1 then
			if tileA == 0 then
				tileA = 99
				tileB = 0
				tileC = -1
				tileD = 0
			elseif tileA == 99 then
				tileA = 0
				tileB = 99
				tileC = 1
				tileD = 0
			end
		elseif tileD == 0 then
			tileD = tileD + 1
		end
	end
end

identity.dropnpg = function()
    world = identity.splitt(setting.mode.worldnpg[index],"[^:]+")[1]
    identity.door = identity.splitt(setting.mode.worldnpg[index],"[^:]+")[2]
	setJob("Dropping NPG")
    identity.warp(world,identity.door)
    if not nuked then
        if not wrong then
            while findItem(6086) > 0 do
                drop(6086)
                sleep(setting.delay.drop)
            end
        else
            print("Id door world npg is wrong, check ur id door !!")
            identity.botinfo("Id door world npg is wrong, check ur id door !! @everyone")
            error()
        end
    else
        print("World npg is nuked, check ur world !!")
        identity.botinfo("World npg is nuked, check ur world !! @everyone")
        error()
    end
end

identity.npg = function()
    world = identity.splitt(setting.mode.worldnpg[index],"[^:]+")[1]
    identity.door = identity.splitt(setting.mode.worldnpg[index],"[^:]+")[2]
    setJob("Taking NPG")
    identity.warp(world,identity.door)
    if not nuked then
        if not wrong then
            while findItem(6086) == 0 do
                for _, obj in pairs(getObjects()) do
                    if obj.id == 6086 then
                        findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                        sleep(1000)
                        collect(2)
                        sleep(1000)
                    end
                    if findItem(6086) > 0  then
                        break
                    end
                end
            end
            wear(6086)
            sleep(500)
            move(-1,0)
            sleep(1000)
            if findItem(6086) > 1 then
                drop(6086,findItem(6086) - 1)
                sleep(setting.delay.drop)
            end
        else
            print("Id door world npg is wrong, check ur id door !!")
            identity.botinfo("Id door world npg is wrong, check ur id door !! @everyone")
            error()
        end
    else
        print("World npg is nuked, check ur world !!")
        identity.botinfo("World npg is nuked, check ur world !! @everyone")
        error()
    end
end

identity.killing = function()
    for _, worlds in pairs(farmList) do
        identity.door = idList
        setJob("Killing ghost")
        identity.warp(worlds,identity.door)
        if not nuked then
            if not wrong then
                sleep(setting.delay.killghost)
            else
                wrong = false
                sleep(1000)
                print(""..worlds.." is wrong door id, skipped world")
                identity.botinfo("[ ||"..worlds.."|| ] is wrong door id, skipped world @everyone")
            end
        else
            nuked = false
            sleep(1000)
            print(""..worlds.." is NUKED!, check ur world !!")
            identity.botinfo("[ ||"..worlds.."|| ] is NUKED!, check ur world !! @everyone")
        end
    end
end

if BizzantiuM.version == "1.1" and BizzantiuM.handler == "akbarsht" then
    sleep(math.random(300,3000))
    if setting.mode.killghost then
        if findItem(6086) == 0 then
            identity.npg()
            identity.killing()
            identity.dropnpg()
        else
            identity.killing()
            identity.dropnpg()
        end
        print("All ghost are killed, please disable auto kill ghost then re-execute script")
        identity.botinfo("All ghost are killed, please disable auto kill ghost then re-execute script @everyone")
        error()
    end
	for idx , value in ipairs(worlds) do
		identity.door = setting.farmList.door
		setJob("Planting")
		identity.warp(value,identity.door)
		if not nuked then
			if not wrong then
				identity.plant(value)
				identity.recheck(value)
				timer[value] = ""..identity.goodtimes(os.difftime(os.time(),identity.goodtime))..""
            else
                timer[value] = "WRONG DOOR ID"
                wrong = false
                sleep(1000)
                print("[ "..value.." ] is wrong door id, skipped world")
            end
        else
            timer[value] = "NUKED"
            nuked = false
            sleep(1000)
            print(""..value.." is NUKED!, check ur world !!")
            identity.webhookinfo("[ ||"..value.."|| ] is NUKED!, check ur world !! @everyone")
        end
	end
end
print("Allready finished all world, removing bot!")
identity.botinfo("[ ||"..getBot().name.."|| ] Allready finished all world, removing bot! @everyone")
identity.webhookinfo("Allready finished all world, removing bot!")
if setting.removeBot then
	removeBot(getBot().name)
	sleep(100)
end
error()
